upstream pageboard {
  server 127.0.0.1:17000;
}

lua_package_path './rocks/share/lua/5.1/?.lua;';

lua_shared_dict prometheus_metrics 128k;

# The "auto_ssl" shared dict should be defined with enough storage space to
# hold your certificate data. 1MB of storage holds certificates for
# approximately 100 separate domains.
lua_shared_dict auto_ssl 10m;
# The "auto_ssl" shared dict is used to temporarily store various settings
# like the secret used by the hook server on port 8999. Do not change or
# omit it.
lua_shared_dict auto_ssl_settings 64k;

# A DNS resolver must be defined for OCSP stapling to function.
#
# This example uses Google's DNS server. You may want to use your system's
# default DNS servers, which can be found in /etc/resolv.conf. If your network
# is not IPv6 compatible, you may wish to disable IPv6 results by using the
# "ipv6=off" flag (like "resolver 8.8.8.8 ipv6=off").
resolver 127.0.0.1 ipv6=off;

# reasonable limits
limit_req_zone $binary_remote_addr zone=ratePerIP:10m rate=1r/s;
limit_req_zone $host zone=ratePerHost:10m rate=100r/s;
limit_req_status 429;

# Initial setup tasks.
init_by_lua_block {
  local devel = false
  upcache = require "upcache"
  auto_ssl = (require "resty.auto-ssl").new()
  
  local wildcard = "pageboard.fr"
  if devel then
    wildcard = "localhost.localdomain"
    ngx.log(ngx.WARN, "Using localhost.localdomain, clean with chrome://net-internals/#hsts")
  end
  ngx.log(ngx.WARN, "Configured with wildcard "..wildcard)
  
  -- prepare wildcard key and full cert der
  local ssl = require "ngx.ssl"
  local keyDer
  local file, err = io.open("./nginx/ssl/cert/privkey.pem", "r")
  if err then
    ngx.log(ngx.ERR, err)
  else
    keyDer = ssl.priv_key_pem_to_der(file:read("*a"))
    file:close()
    file = nil
  end
  local fullDer
  file, err = io.open("./nginx/ssl/cert/fullchain.pem", "r")
  if err then
    ngx.log(ngx.ERR, err)
  else
    fullDer = ssl.cert_pem_to_der(file:read("*a"))
    file:close()
    file = nil
  end

  auto_ssl:set("hook_server_port", 17099)
  auto_ssl:set("dir", (require "lfs").currentdir() .. "/autossl")
  if devel then
    auto_ssl:set("ca", "https://acme-staging.api.letsencrypt.org/directory")
    ngx.log(ngx.WARN, "Configured with staging acme ca")
  end

  auto_ssl:set("request_domain", function(ssl, ssl_options)
    local domain, err = ssl.server_name()
    if not err and domain and string.sub(domain, -string.len(wildcard)) == wildcard then
      ssl_options.privkey_der = keyDer
      ssl_options.fullchain_der = fullDer
    end
    local addr, addrtyp, addrerr = ssl.raw_server_addr()
    local byte = string.byte
    if not addrerr and addrtyp == "inet" then  -- IPv4
      ssl_options.server_addr = string.format("%d.%d.%d.%d", byte(addr, 1), byte(addr, 2),
                         byte(addr, 3), byte(addr, 4))
    elseif addrtyp == "unix" or addrtyp == "inet6" then  -- UNIX or ipv6
      ngx.log(ngx.ERR, "only ipv4 supported here")
      err = addrerr
    end
    return domain, err
  end)

  -- Define a function to determine which SNI domains to automatically handle
  -- and register new certificates for. Defaults to not allowing any domains,
  -- so this must be configured.
  auto_ssl:set("allow_domain", function(domain, autossl, ssl_options)
    -- never consider empty domain or a domain that is actually an IP
  	if domain == nil or domain == "" or string.match(domain, "(%d+).(%d+).(%d+).(%d+)") or string.find(domain, ":", 1, true) then
      ngx.log(ngx.ERR, "allow_domain rejects: "..domain)
      return false
    end
    local http = require "resty.http"
    local httpc = http.new()
    -- TODO: use "upstream" module to find out the address
    local res, err = httpc:request_uri("http://127.0.0.1:17000/.well-known/pageboard", {
      method = "GET",
      headers = {
        ["X-Forwarded-By"] = ssl_options.server_addr,
        ["Host"] = domain,
        ["Accept"] = "text/plain"
      }
    })

    if err ~= nil then
      ngx.log(ngx.ERR, err)
      return false
    elseif res.status ~= 200 then
      return false
    else
      return true
    end
  end)

  auto_ssl:init()
  
  prometheus = require("nginx.prometheus").init("prometheus_metrics")
  metric_requests = prometheus:counter(
    "nginx_http_requests_total", "Number of HTTP requests", {"status"})
  metric_latency = prometheus:histogram(
    "nginx_http_request_duration_seconds", "HTTP request latency", {})
}

log_by_lua_block {
  metric_requests:inc(1, {ngx.var.status})
  metric_latency:observe(tonumber(ngx.var.request_time), {})
}

init_worker_by_lua_block {
  auto_ssl:init_worker()
}

# Internal server running on port 8999 for handling certificate tasks.
server {
  listen 127.0.0.1:17099;

  # Increase the body buffer size, to ensure the internal POSTs can always
  # parse the full POST contents into memory.
  client_body_buffer_size 128k;
  client_max_body_size 128k;

  location / {
    content_by_lua_block {
      auto_ssl:hook_server()
    }
  }
}

server {
  listen pageboard.fr:17443 ssl http2 default_server bind;
  server_name _;
  # use for debugging only
  # access_log access.log;
  
  http2_push_preload on;

  ssl_certificate_key ssl/cert/privkey.pem;
  ssl_certificate     ssl/cert/fullchain.pem;

  ssl_certificate_by_lua_block {
    -- pass empty ssl_options
    auto_ssl:ssl_certificate({})
  }

  include snippets/upcache-server.conf;

  if ($host = $server_addr) {
    return 400 "Bad hostname";
  }
  error_page 500 502 503 504 @error;
  error_page 555 = @notget;

  if ($request_uri ~ \.(htm|php|xml|cgi)$) {
    return 404;
  }

  if ($request_method !~ ^(GET|HEAD)$) {
    return 555;
  }

  location @notget {
    limit_req zone=ratePerIP burst=3;
    limit_req zone=ratePerHost burst=100 nodelay;
    include snippets/upcache-location.conf;
    srcache_store_max_size 10m;
    include proxy_params.conf;
    proxy_pass http://pageboard;
    proxy_intercept_errors on;
  }

  location @error {
    root statics/;
    try_files /status.html =503;
  }

  location / {
    include snippets/upcache-location.conf;
    srcache_store_max_size 10m;
    include proxy_params.conf;
    proxy_pass http://pageboard;
    proxy_intercept_errors on;
  }
}

server {
  listen pageboard.fr:17080 default_server bind;
  server_name _;

  location /.well-known/acme-challenge/ {
    content_by_lua_block {
      auto_ssl:challenge_server()
    }
  }

  if ($host = $server_addr) {
    return 400 "Bad hostname";
  }

  location / {
    # limit_except GET implies also HEAD
    limit_except GET {
      deny all;
    }
    return 301 https://$host$request_uri;
  }
}

server {
  listen 17401;
  location / {
    content_by_lua_block {
      prometheus:collect()
    }
  }
}

